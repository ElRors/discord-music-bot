const { Client, GatewayIntentBits, Collection } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus } = require('@discordjs/voice');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Cargar librer√≠a de encriptaci√≥n para audio
try {
    require('libsodium-wrappers');
    console.log('‚úÖ Librer√≠a de encriptaci√≥n cargada');
} catch (error) {
    console.log('‚ö†Ô∏è Advertencia: No se pudo cargar libsodium-wrappers');
}

// Cargar codec de audio Opus
try {
    require('@discordjs/opus');
    console.log('‚úÖ Codec Opus cargado');
} catch (error) {
    console.log('‚ö†Ô∏è Advertencia: No se pudo cargar @discordjs/opus');
}

// Crear cliente de Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// Colecci√≥n para comandos
client.commands = new Collection();

// Map para almacenar conexiones de voz
client.voiceConnections = new Map();

// Cargar comandos
const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);
    client.commands.set(command.data.name, command);
}

// Funci√≥n helper para crear controles de m√∫sica
function createMusicControls() {
    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
    
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('music_skip')
                .setLabel('‚è≠Ô∏è Skip')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('music_pause')
                .setLabel('‚è∏Ô∏è Pause')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('music_resume')
                .setLabel('‚ñ∂Ô∏è Resume')
                .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
                .setCustomId('music_queue')
                .setLabel('üìä Queue')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('music_stop')
                .setLabel('‚èπÔ∏è Stop')
                .setStyle(ButtonStyle.Danger)
        );
}

// Funci√≥n helper para mostrar controles autom√°ticamente despu√©s de acciones
async function showControlsAfterAction(channel, message) {
    try {
        if (!channel) return;
        
        await channel.send({
            content: message,
            components: [createMusicControls()]
        });
        
        console.log('‚úÖ Controles autom√°ticos enviados despu√©s de acci√≥n');
    } catch (error) {
        console.error('‚ùå Error enviando controles despu√©s de acci√≥n:', error);
    }
}

// Evento cuando el bot est√° listo
client.once('ready', () => {
    console.log(`‚úÖ Bot conectado como ${client.user.tag}!`);
    console.log(`üéµ Bot de m√∫sica listo para usar en ${client.guilds.cache.size} servidores`);
});

// Manejar comandos
client.on('interactionCreate', async interaction => {
    console.log(`üîç Interacci√≥n recibida: ${interaction.commandName || interaction.customId || 'sin comando'}`);
    
    // Manejar botones de m√∫sica
    if (interaction.isButton()) {
        const { customId } = interaction;
        
        if (customId.startsWith('music_')) {
            await handleMusicButton(interaction, customId);
            return;
        }
    }
    
    if (!interaction.isChatInputCommand()) return;

    const command = client.commands.get(interaction.commandName);

    if (!command) {
        console.log(`‚ùå Comando no encontrado: ${interaction.commandName}`);
        return;
    }

    try {
        console.log(`‚ö° Ejecutando comando: ${interaction.commandName}`);
        await command.execute(interaction);
        console.log(`‚úÖ Comando ejecutado exitosamente: ${interaction.commandName}`);
    } catch (error) {
        console.error('Error ejecutando comando:', error);
        await interaction.reply({ 
            content: '‚ùå Hubo un error al ejecutar este comando!', 
            ephemeral: true 
        });
    }
});

// Funci√≥n para manejar botones de m√∫sica
async function handleMusicButton(interaction, customId) {
    try {
        // Verificar que el usuario est√© en un canal de voz
        if (!interaction.member.voice.channel) {
            return await interaction.reply({ 
                content: '‚ùå Debes estar en un canal de voz para usar los controles!', 
                ephemeral: true 
            });
        }

        switch (customId) {
            case 'music_skip':
                // Verificar si hay m√∫sica reproduci√©ndose
                if (!global.audioPlayer || !global.currentConnection) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                // Verificar si hay m√°s canciones en la cola
                if (!global.musicQueue || global.musicQueue.length === 0) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√°s canciones en la cola para saltar.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.stop();
                await interaction.reply('‚è≠Ô∏è **Canci√≥n saltada** por ' + interaction.user.displayName);
                break;

            case 'music_pause':
                if (!global.audioPlayer) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.pause();
                await interaction.reply('‚è∏Ô∏è **M√∫sica pausada** por ' + interaction.user.displayName);
                break;

            case 'music_resume':
                if (!global.audioPlayer) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.unpause();
                await interaction.reply('‚ñ∂Ô∏è **M√∫sica reanudada** por ' + interaction.user.displayName);
                break;

            case 'music_queue':
                // Mostrar la cola de m√∫sica
                if (!global.musicQueue || global.musicQueue.length === 0) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay canciones en la cola.', 
                        ephemeral: true 
                    });
                }

                const { EmbedBuilder } = require('discord.js');
                const itemsPerPage = 10;
                const totalPages = Math.ceil(global.musicQueue.length / itemsPerPage);
                const queueSlice = global.musicQueue.slice(0, itemsPerPage); // Mostrar primera p√°gina

                const embed = new EmbedBuilder()
                    .setColor('#1DB954')
                    .setTitle('üéµ Cola de Reproducci√≥n')
                    .addFields(
                        { name: 'üìä Estado', value: global.audioPlayer ? 'Reproduciendo' : 'Detenido', inline: true },
                        { name: 'üéµ Canciones en cola', value: global.musicQueue.length.toString(), inline: true },
                        { name: 'üîÄ Shuffle', value: global.guildSettings?.[interaction.guild.id]?.shuffle ? 'Activado' : 'Desactivado', inline: true }
                    )
                    .setTimestamp();

                let queueText = '';
                queueSlice.forEach((song, index) => {
                    const position = index + 1;
                    const title = song.title || 'T√≠tulo desconocido';
                    const artist = song.artist ? ` por **${song.artist}**` : '';
                    const source = song.isSpotify ? '[SPOTIFY‚ÜíYT]' : '[YOUTUBE]';
                    queueText += `**${position}.** ${title}${artist} ${source}\n`;
                });

                if (queueText) {
                    embed.addFields({
                        name: `üîÑ Pr√≥ximas Canciones (P√°gina 1/${totalPages})`,
                        value: queueText,
                        inline: false
                    });
                }

                embed.setFooter({ 
                    text: `Usa /queue para ver la cola completa con paginaci√≥n`
                });

                await interaction.reply({ embeds: [embed], ephemeral: true });
                break;

            case 'music_stop':
                if (!global.audioPlayer && !global.currentConnection) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                // Limpiar la cola
                global.musicQueue = [];
                
                // Detener el reproductor global si existe
                if (global.audioPlayer) {
                    global.audioPlayer.stop();
                    global.audioPlayer = null;
                }
                
                // Desconectar del canal de voz
                if (global.currentConnection) {
                    global.currentConnection.destroy();
                    global.currentConnection = null;
                }
                
                // Limpiar referencias globales
                global.lastVoiceChannel = null;
                global.lastTextChannel = null;

                await interaction.reply('‚èπÔ∏è **M√∫sica detenida** por ' + interaction.user.displayName);
                break;

            default:
                await interaction.reply({ 
                    content: '‚ùå Bot√≥n no reconocido.', 
                    ephemeral: true 
                });
        }
    } catch (error) {
        console.error('Error manejando bot√≥n de m√∫sica:', error);
        await interaction.reply({ 
            content: '‚ùå Error al procesar el control de m√∫sica.', 
            ephemeral: true 
        });
    }
}

// Manejar errores
client.on('error', error => {
    console.error('Error del cliente Discord:', error);
});

process.on('unhandledRejection', error => {
    console.error('Unhandled promise rejection:', error);
});

// Iniciar el bot
client.login(process.env.DISCORD_TOKEN);
