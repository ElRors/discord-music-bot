const { Client, GatewayIntentBits, Collection } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus } = require('@discordjs/voice');
const fs = require('fs');
const path = require('path');
const musicState = require('./utils/musicState');
require('dotenv').config();

// Cargar librer√≠a de encriptaci√≥n para audio
try {
    require('libsodium-wrappers');
    console.log('‚úÖ Librer√≠a de encriptaci√≥n cargada');
} catch (error) {
    console.log('‚ö†Ô∏è Advertencia: No se pudo cargar libsodium-wrappers');
}

// Cargar codec de audio Opus
try {
    require('@discordjs/opus');
    console.log('‚úÖ Codec Opus cargado');
} catch (error) {
    console.log('‚ö†Ô∏è Advertencia: No se pudo cargar @discordjs/opus');
}

// Crear cliente de Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildVoiceStates
    ]
});

// Colecci√≥n para comandos
client.commands = new Collection();

// Map para almacenar conexiones de voz
client.voiceConnections = new Map();

// Variables globales para auto-desconexi√≥n por inactividad
global.inactivityTimeout = null;
global.INACTIVITY_LIMIT = 45000; // 45 segundos en milisegundos

// Variables globales para modo radio/autoplay
global.radioMode = false; // Si est√° activado el modo radio
global.lastPlayedSongs = []; // Historial de canciones para recomendaciones
global.MAX_HISTORY = 10; // M√°ximo de canciones en el historial

// Funciones globales para manejar auto-desconexi√≥n por inactividad
global.startInactivityTimer = function() {
    // Cancelar timer existente si hay uno
    if (global.inactivityTimeout) {
        clearTimeout(global.inactivityTimeout);
    }
    
    console.log('‚è∞ Iniciando timer de inactividad (45 segundos)');
    global.inactivityTimeout = setTimeout(() => {
        global.disconnectFromVoice();
    }, global.INACTIVITY_LIMIT);
};

global.cancelInactivityTimer = function() {
    if (global.inactivityTimeout) {
        clearTimeout(global.inactivityTimeout);
        global.inactivityTimeout = null;
        console.log('‚úÖ Timer de inactividad cancelado');
    }
};

global.disconnectFromVoice = function() {
    try {
        console.log('üö∂ Desconectando por inactividad...');
        
        // Limpiar la cola
        global.musicQueue = [];
        
        // Detener el reproductor global si existe
        if (global.audioPlayer) {
            global.audioPlayer.stop();
            global.audioPlayer = null;
        }
        
        // Desconectar del canal de voz
        if (global.currentConnection) {
            global.currentConnection.destroy();
            global.currentConnection = null;
        }
        
        // Limpiar referencias globales
        global.lastVoiceChannel = null;
        global.currentSong = null;
        global.inactivityTimeout = null;
        
        // Enviar mensaje de desconexi√≥n si hay canal de texto
        if (global.lastTextChannel) {
            global.lastTextChannel.send('üö∂ **Bot desconectado por inactividad** (45 segundos sin m√∫sica)')
                .catch(err => console.log('No se pudo enviar mensaje de desconexi√≥n:', err));
            global.lastTextChannel = null;
        }
        
        console.log('‚úÖ Desconectado exitosamente por inactividad');
    } catch (error) {
        console.error('‚ùå Error al desconectar por inactividad:', error);
    }
};

// Cargar comandos
const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);
    client.commands.set(command.data.name, command);
}

// Funci√≥n helper para crear controles de m√∫sica
function createMusicControls() {
    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
    
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('music_skip')
                .setLabel('‚è≠Ô∏è Skip')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('music_pause')
                .setLabel('‚è∏Ô∏è Pause')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('music_resume')
                .setLabel('‚ñ∂Ô∏è Resume')
                .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
                .setCustomId('music_queue')
                .setLabel('üìä Queue')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('music_stop')
                .setLabel('‚èπÔ∏è Stop')
                .setStyle(ButtonStyle.Danger)
        );
}

// Funci√≥n helper para mostrar controles autom√°ticamente despu√©s de acciones
async function showControlsAfterAction(channel, message) {
    try {
        if (!channel) return;
        
        await channel.send({
            content: message,
            components: [createMusicControls()]
        });
        
        console.log('‚úÖ Controles autom√°ticos enviados despu√©s de acci√≥n');
    } catch (error) {
        console.error('‚ùå Error enviando controles despu√©s de acci√≥n:', error);
    }
}

// Evento cuando el bot est√° listo
client.once('ready', () => {
    console.log(`‚úÖ Bot conectado como ${client.user.tag}!`);
    console.log(`üéµ Bot de m√∫sica listo para usar en ${client.guilds.cache.size} servidores`);
});

// Manejar comandos
client.on('interactionCreate', async interaction => {
    console.log(`üîç Interacci√≥n recibida: ${interaction.commandName || interaction.customId || 'sin comando'}`);
    
    // Manejar botones de m√∫sica
    if (interaction.isButton()) {
        const { customId } = interaction;
        
        if (customId.startsWith('music_')) {
            await handleMusicButton(interaction, customId);
            return;
        }
    }
    
    if (!interaction.isChatInputCommand()) return;

    const command = client.commands.get(interaction.commandName);

    if (!command) {
        console.log(`‚ùå Comando no encontrado: ${interaction.commandName}`);
        return;
    }

    try {
        console.log(`‚ö° Ejecutando comando: ${interaction.commandName}`);
        await command.execute(interaction);
        console.log(`‚úÖ Comando ejecutado exitosamente: ${interaction.commandName}`);
    } catch (error) {
        console.error('Error ejecutando comando:', error);
        await interaction.reply({ 
            content: '‚ùå Hubo un error al ejecutar este comando!', 
            ephemeral: true 
        });
    }
});

// Funci√≥n para manejar botones de m√∫sica
async function handleMusicButton(interaction, customId) {
    try {
        // Verificar que el usuario est√© en un canal de voz
        if (!interaction.member.voice.channel) {
            return await interaction.reply({ 
                content: '‚ùå Debes estar en un canal de voz para usar los controles!', 
                ephemeral: true 
            });
        }

        switch (customId) {
            case 'music_skip':
                // Verificar si hay m√∫sica para saltar
                if (!musicState.hasActiveMusic()) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                // Verificar si hay m√°s canciones en la cola
                if (musicState.getQueueLength() === 0) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√°s canciones en la cola para saltar.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.stop();
                await interaction.reply('‚è≠Ô∏è **Canci√≥n saltada** por ' + interaction.user.displayName);
                break;

            case 'music_pause':
                if (!musicState.isPlaying()) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente o ya est√° pausada.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.pause();
                
                // Iniciar timer de inactividad cuando se pausa
                global.startInactivityTimer();
                
                await interaction.reply('‚è∏Ô∏è **M√∫sica pausada** por ' + interaction.user.displayName);
                break;

            case 'music_resume':
                if (!musicState.isPaused()) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica pausada para reanudar.', 
                        ephemeral: true 
                    });
                }

                global.audioPlayer.unpause();
                
                // Cancelar timer de inactividad cuando se reanuda
                global.cancelInactivityTimer();
                
                await interaction.reply('‚ñ∂Ô∏è **M√∫sica reanudada** por ' + interaction.user.displayName);
                break;

            case 'music_queue':
                // Mostrar la cola de m√∫sica usando funciones centralizadas
                if (!musicState.hasActiveMusic() || musicState.getQueueLength() === 0) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay canciones en la cola.', 
                        ephemeral: true 
                    });
                }

                const { EmbedBuilder } = require('discord.js');
                const itemsPerPage = 10;
                const totalPages = Math.ceil(musicState.getQueueLength() / itemsPerPage);
                const queueSlice = global.musicQueue.slice(0, itemsPerPage); // Mostrar primera p√°gina

                const currentSong = musicState.getCurrentSong();
                const currentInfo = currentSong ? `**üéµ Reproduciendo:** ${currentSong.title}\n\n` : '';

                const embed = new EmbedBuilder()
                    .setColor('#1DB954')
                    .setTitle('üéµ Cola de Reproducci√≥n')
                    .setDescription(currentInfo)
                    .addFields(
                        { name: 'üìä Estado', value: musicState.getPlayerStatus(), inline: true },
                        { name: 'üéµ Canciones en cola', value: musicState.getQueueLength().toString(), inline: true },
                        { name: 'üîÄ Shuffle', value: global.guildSettings?.[interaction.guild.id]?.shuffle ? 'Activado' : 'Desactivado', inline: true }
                    )
                    .setTimestamp();

                let queueText = '';
                queueSlice.forEach((song, index) => {
                    const position = index + 1;
                    const title = song.title || 'T√≠tulo desconocido';
                    const artist = song.artist ? ` por **${song.artist}**` : '';
                    const source = song.isSpotify ? '[SPOTIFY‚ÜíYT]' : '[YOUTUBE]';
                    queueText += `**${position}.** ${title}${artist} ${source}\n`;
                });

                if (queueText) {
                    embed.addFields({
                        name: `üîÑ Pr√≥ximas Canciones (P√°gina 1/${totalPages})`,
                        value: queueText,
                        inline: false
                    });
                }

                embed.setFooter({ 
                    text: `Usa /queue para ver la cola completa con paginaci√≥n`
                });

                await interaction.reply({ embeds: [embed], ephemeral: true });
                break;

            case 'music_stop':
                // Usar la funci√≥n centralizada para verificar y limpiar estado
                if (!musicState.hasActiveMusic()) {
                    return await interaction.reply({ 
                        content: '‚ùå No hay m√∫sica reproduci√©ndose actualmente.', 
                        ephemeral: true 
                    });
                }

                try {
                    musicState.clearMusicState();
                    await interaction.reply('‚èπÔ∏è **M√∫sica detenida** por ' + interaction.user.displayName);
                } catch (error) {
                    console.error('‚ùå Error en bot√≥n detener:', error);
                    await interaction.reply({ 
                        content: '‚ùå Error al detener la m√∫sica, pero se intent√≥ limpiar el estado.', 
                        ephemeral: true 
                    });
                }
                break;

            default:
                await interaction.reply({ 
                    content: '‚ùå Bot√≥n no reconocido.', 
                    ephemeral: true 
                });
        }
    } catch (error) {
        console.error('Error manejando bot√≥n de m√∫sica:', error);
        await interaction.reply({ 
            content: '‚ùå Error al procesar el control de m√∫sica.', 
            ephemeral: true 
        });
    }
}

// Manejar errores
client.on('error', error => {
    console.error('Error del cliente Discord:', error);
});

process.on('unhandledRejection', error => {
    console.error('Unhandled promise rejection:', error);
});

// Iniciar el bot
client.login(process.env.DISCORD_TOKEN);
